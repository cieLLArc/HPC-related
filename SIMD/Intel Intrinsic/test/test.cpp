#include <immintrin.h>
int main()
{
    int m, n, k;
    // 将循环逐层展开，内层循环结束后返回上层循环，
    // A按行访问，行内再依次访问各个元素
    // B按列访问，列内再依次访问各个元素
    // 访存顺序是否影响性能主要看最内层元素的展开？
    // 编译器如何处理循环，什么时候会循环展开，还是使用跳转指令完成循环？

    for (int j = 0; j < n; j++) //
        for (int i = 0; i < m; i++)
            for (int p = 0; p < k; p++)
                C[i][j] += A[i][p] * B[p][j];
    // C在第二层循环中，固定j不变，使用i迭代，跨行访问下一列中的元素，在C语言中二维数组行与行之间地址一般不连续
    // C在第三层循环中，访问固定值
    // A在第三层循环中，固定i不变，使用p迭代，行内访问下一个元素
    // B在第三层循环中，固定j不变，使用p迭代，跨行访问下一列中的元素，难以利用空间局部性

    for (int i = 0; i < m; i++)
        for (int p = 0; p < k; p++)
            for (int j = 0; j < n; j++)
                C[i][j] += A[i][p] * B[p][j];
    //  C在第三层循环中，固定i不变，使用j迭代，行内访问下一个元素
    //  A在第二层循环中，固定i不变，使用p迭代，行内访问下一个元素
    //  A在第三层循环中，固定i，p不变，访问固定值
    //  B在第三层循环中，固定p不变，使用j迭代，行内访问下一列中的元素,可以利用空间局部性，cache命中率高

    for (int i = 0; i < m; i++)
    {
        for (int p = 0; p < k; p++)
        {
            int temp = A[i][p];
            for (int j = 0; j < n; j++)
            {
                C[i][j] += temp * B[p][j];
            }
        }
    }
    // 利用了上一种C语言访存友好的写法，将A矩阵的值先保存起来，减少后续对同一值的访存次数

    for (int p = 0; p < k; p++)
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                C[i][j] += A[i][p] * B[p][j];
    // C在第三层循环中，固定i不变，使用j迭代，行内访问下一个元素
    // A在第二层循环中，固定p不变，使用i迭代，跨行访问下一列中的元素
    // A在第三层循环中，固定i，p不变，访问固定值
    // B在第三层循环中，固定p不变，使用j迭代，行内访问下一列中的元素

    __m256d a = _mm256_set1_pd(1.0);
    __m256d b = _mm256_add_pd(a, a);
    return 0;
}
